(ns clj-whitespace.core
  (:require [clj-whitespace.parser :as parser]
            [clj-whitespace.compiler :as compiler]
            [clj-whitespace.programs :as programs]
            [clj-whitespace.runtime :as runtime]
            [clojure.string :as string]
            [clojure.tools.cli :refer [parse-opts]])
  (:gen-class))

(def cli-options
  [["-i" "--intermediate" "Execute Clojure-Whitespace source generated by the compiler" :default false]
   ["-c" "--compile" "Compile whitespace program into intermediate code" :default false]
   ["-h" "--help" :default false]])

(defn usage [options-summary]
(->> ["This program compiles and executes Whitespace source, producing an intermediate representation."
      ""
      "Usage: clj-whitespace [options] source-file"
      ""
      "Options:"
      options-summary
      ""]
      (string/join \newline)))

(defn error-msg [errors]
  (str "The following errors occurred while parsing your command:\n\n"
        (string/join \newline errors)))

(defn validate-args [args]
  "We validate arguments for functionality in the main method."
  (let [{:keys [options arguments errors summary]} (parse-opts args cli-options)]
    (cond
      (:help options) {:exit-message (usage summary) :ok? true}
      errors {:exit-message (error-msg errors)}
      (and (= 1 (count arguments)) (:compile options) (not (:intermediate options)))
        {:action :compile-source :file (first arguments)}
      (and (= 1 (count arguments)) (not (:compile options)) (:intermediate options))
        {:action :execute-intermediate :file (first arguments)}
      (and (= 1 (count arguments)) (not (:compile options)) (not (:intermediate options)))
        {:action :execute-source :file (first arguments)}
      :else ; failed custom validation => exit with usage summary
      {:exit-message (usage summary)})))

(defn -main [& args]
  (let [{:keys [action file exit-message ok?]} (validate-args args)]
    (if exit-message
      (do (println exit-message) 
          (System/exit (if ok? 0 1)))
      (case action
        :compile-source  (parser/parse file :mode :file :intermediate? true)
        :execute-intermediate (let [[prgm labels] (compiler/compile-tokens (eval (read-string (slurp file))))]
                                (runtime/main-routine prgm labels))
        :execute-source (runtime/exec file :mode :file)))))

